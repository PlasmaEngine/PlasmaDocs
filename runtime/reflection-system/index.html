<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="PlasmaDev">
    <link rel="canonical" href="https://plasmaengine.github.io/PlasmaDocs/runtime/reflection-system/">
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>Reflection System - PlasmaDocs</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "Reflection System", url: "#_top", children: [
              {title: "Types", url: "#types" },
              {title: "Properties", url: "#properties" },
              {title: "Flags", url: "#flags" },
              {title: "Limitations", url: "#limitations" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script>
      <script src="../../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../resource-management/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../resource-management/" class="btn btn-xs btn-link">
        Resource Management
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../filesystem/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../filesystem/" class="btn btn-xs btn-link">
        FileSystem
      </a>
    </div>
    
  </div>

    

    <h1 id="reflection-system">Reflection System</h1>
<p>The Plasma Engine reflection system allows to inspect structs and classes at runtime. It is used primarily for communication with tools and serialization.
The reflection system is macro-based, meaning that it is not generated automatically but needs to be written manually for each type, member, etc that needs to be known at runtime.</p>
<h2 id="types">Types</h2>
<p>There are four distinct types that can be represented by reflection: classes, structs, enums and bitflags. Each is represented by the <code>plRTTI</code> class that stores the type information.</p>
<h3 id="classes">Classes</h3>
<p>Classes are separated into two types: dynamic and static reflected. Dynamic classes derive from <code>plReflectedClass</code> which allows you to determine its type using <code>plReflectedClass::GetDynamicRTTI()</code>. So with a pointer to an <code>plReflectedClass</code> you can access its type information.</p>
<p>A static reflected class does not derive from <code>plReflectedClass</code> so it is not possible to get the RTTI information in a common way. However, if you know the type of a variable you can use the template function <code>plGetStaticRTTI</code> to retrieve the <code>plRTTI</code> instance of a specific type. Alternatively, you can also search for a type by name using <code>plRTTI::FindTypeByName()</code>.</p>
<pre><code class="language-cpp">plReflectedClass* pTest = new plDynamicTestClass;
const plRTTI* pRtti = pTest-&gt;GetDynamicRTTI();
const plRTTI* pRtti2 = plGetStaticRTTI&lt;plDynamicTestClass&gt;();
const plRTTI* pRtti3 = plRTTI::FindTypeByName(&quot;plDynamicTestClass&quot;);
</code></pre>
<p>Declaring a dynamic class involves deriving from <code>plReflectedClass</code>, adding the <code>PLASMA_ADD_DYNAMIC_REFLECTION(SELF, BASE_TYPE)</code> macro into the class body and adding a <code>PLASMA_BEGIN_DYNAMIC_REFLECTED_TYPE(Type, Version, AllocatorType)</code> block into a compilation unit.</p>
<pre><code class="language-cpp">//Header
class plDynamicTestClass : public plReflectedClass
{
  PLASMA_ADD_DYNAMIC_REFLECTION(plDynamicTestClass, plReflectedClass);
};
</code></pre>
<pre><code class="language-cpp">//Cpp
PLASMA_BEGIN_DYNAMIC_REFLECTED_TYPE(plDynamicTestClass, 1, plRTTIDefaultAllocator&lt;plDynamicTestClass&gt;)
PLASMA_END_DYNAMIC_REFLECTED_TYPE
</code></pre>
<p>Declaring a static class is very similar to declaring a dynamic class. However, you need to declare the type outside the class via <code>PLASMA_DECLARE_REFLECTABLE_TYPE(Linkage, TYPE)</code> and use <code>PLASMA_BEGIN_STATIC_REFLECTED_TYPE(Type, BaseType, Version, AllocatorType)</code> in a compilation unit. If a class has no base class, use the dummy class <code>plNoBase</code> instead.</p>
<pre><code class="language-cpp">// Header
class plStaticTestClass
{
};
PLASMA_DECLARE_REFLECTABLE_TYPE(PLASMA_NO_LINKAGE, plStaticTestClass);
</code></pre>
<pre><code class="language-cpp">// Cpp
PLASMA_BEGIN_STATIC_REFLECTED_TYPE(plStaticTestClass, plNoBase, 1, plRTTIDefaultAllocator&lt;plStaticTestClass&gt;);
PLASMA_END_STATIC_REFLECTED_TYPE
</code></pre>
<h3 id="structs">Structs</h3>
<p>Structs are identical to static reflected classes so you can use the exact same macros.</p>
<h3 id="enums">Enums</h3>
<p>Enums are limited to structured enums, i.e. those used by the <code>plEnum</code> class. Declaration is similar to static classes, but you use <code>PLASMA_BEGIN_STATIC_REFLECTED_ENUM(Type, Version)</code> instead in the compilation unit code.</p>
<pre><code class="language-cpp">// Header
struct plExampleEnum
{
    typedef plInt8 StorageType;
    enum Enum
    {
    Value1 = 1,          // normal value
    Value2 = -2,         // normal value
    Value3 = 4,          // normal value
    Default = Value1     // Default initialization value (required)
    };
};
PLASMA_DECLARE_REFLECTABLE_TYPE(PLASMA_NO_LINKAGE, plExampleEnum);
</code></pre>
<pre><code class="language-cpp">// Cpp
PLASMA_BEGIN_STATIC_REFLECTED_ENUM(plExampleEnum, 1)
  PLASMA_ENUM_CONSTANTS(plExampleEnum::Value1, plExampleEnum::Value2)
  PLASMA_ENUM_CONSTANT(plExampleEnum::Value3),
PLASMA_END_STATIC_REFLECTED_ENUM
</code></pre>
<p>The enum constants can either be declared via <code>PLASMA_ENUM_CONSTANTS()</code> or <code>PLASMA_ENUM_CONSTANT(Value)</code> inside the begin / end block of the enum declaration. An enum type can be identified by its base type which is always the dummy <code>plEnumBase</code>.</p>
<h3 id="bitflags">Bitflags</h3>
<p>Bitflags are limited to structured bitflags, i.e. those used by the <code>plBitflags</code> class. Declaration is similar to static classes, but you use <code>PLASMA_BEGIN_STATIC_REFLECTED_BITFLAGS(Type, Version)</code> instead in the compilation unit code.</p>
<pre><code class="language-cpp">// Header
struct plExampleBitflags
{
    typedef plUInt64 StorageType;
    enum Enum : plUInt64
    {
    Value1 = PLASMA_BIT(0),  // normal value
    Value2 = PLASMA_BIT(31), // normal value
    Value3 = PLASMA_BIT(63), // normal value
    Default = Value1     // Default initialization value (required)
    };

    struct Bits
    {
    StorageType Value1 : 1;
    StorageType Padding : 30;
    StorageType Value2 : 1;
    StorageType Padding2 : 31;
    StorageType Value3 : 1;
    };
};
PLASMA_DECLARE_REFLECTABLE_TYPE(PLASMA_NO_LINKAGE, plExampleBitflags);
</code></pre>
<pre><code class="language-cpp">// Cpp
PLASMA_BEGIN_STATIC_REFLECTED_BITFLAGS(plExampleBitflags, 1)
  PLASMA_BITFLAGS_CONSTANTS(plExampleBitflags::Value1, plExampleBitflags::Value2)
  PLASMA_BITFLAGS_CONSTANT(plExampleBitflags::Value3),
PLASMA_END_STATIC_REFLECTED_BITFLAGS();
</code></pre>
<p>The bitflags constants can either be declared via <code>PLASMA_BITFLAGS_CONSTANTS()</code> or <code>PLASMA_BITFLAGS_CONSTANT(Value)</code> inside the begin / end block of the bitflags declaration. A bitflags type can be identified by its base type which is always the dummy <code>plBitflagsBase</code>.</p>
<h2 id="properties">Properties</h2>
<p>Properties are the most important information in a type as they define the data inside it. The properties of a type can be accessed via <code>plRTTI::GetProperties()</code>. There are different categories of properties, each deriving from <code>plAbstractProperty</code>. The type of property can be determined by calling <code>plAbstractProperty::GetCategory()</code>.
Properties are added via the property macros inside the <code>PLASMA_BEGIN_PROPERTIES()</code> / <code>PLASMA_END_PROPERTIES()</code> block of the type declaration like this:</p>
<pre><code class="language-cpp">PLASMA_BEGIN_STATIC_REFLECTED_TYPE(plStaticTestClass, plNoBase, 1, plRTTIDefaultAllocator&lt;plStaticTestClass&gt;)
{
    PLASMA_BEGIN_PROPERTIES
    {
        PLASMA_CONSTANT_PROPERTY(&quot;Constant&quot;, 5),
        PLASMA_MEMBER_PROPERTY(&quot;Member&quot;, m_fFloat),
        PLASMA_ACCESSOR_PROPERTY(&quot;MemberAccessor&quot;, GetInt, SetInt),
        PLASMA_ARRAY_MEMBER_PROPERTY(&quot;Array&quot;, m_Deque),
        PLASMA_ARRAY_ACCESSOR_PROPERTY(&quot;ArrayAccessor&quot;, GetCount, GetValue, SetValue, Insert, Remove),
        PLASMA_SET_MEMBER_PROPERTY(&quot;Set&quot;, m_SetMember),
        PLASMA_SET_ACCESSOR_PROPERTY(&quot;SetAccessor&quot;, GetSet, SetInsert, SetRemove),
    }
    PLASMA_END_PROPERTIES
}
PLASMA_END_STATIC_REFLECTED_TYPE();
</code></pre>
<h3 id="constants">Constants</h3>
<p>Constants are declared via <code>PLASMA_CONSTANT_PROPERTY(PropertyName, Value)</code>. The value is stored within the property so no instance of the class is necessary to access it. To access the constant, cast the property to <code>plAbstractConstantProperty</code> and call <code>plAbstractConstantProperty::GetPropertyType()</code> to determine the constant type. Then either cast to <code>plTypedConstantProperty</code> of the matching type, or if the type is not known to you at compile time, use <code>plAbstractConstantProperty::GetPropertyPointer()</code> to access its data.</p>
<h3 id="members">Members</h3>
<p>There are two types of member properties, direct member properties and accessor properties. The first has direct access to the memory location of the property in the class while the later uses functions to get and set the property's value.
Direct member properties are declared via <code>PLASMA_MEMBER_PROPERTY(PropertyName, MemberName)</code> while accessor properties are declared via <code>PLASMA_ACCESSOR_PROPERTY(PropertyName, Getter, Setter)</code>. The getter and setter functions must have the following signature:</p>
<pre><code class="language-cpp">Type GetterFunc() const;
void SetterFunc(Type value);
</code></pre>
<p>Type can be decorated with const and reference but must be consistent between get and set function. The available macros are the following:</p>
<pre><code class="language-cpp">PLASMA_MEMBER_PROPERTY(&quot;Member&quot;, m_fFloat1),
PLASMA_MEMBER_PROPERTY_READ_ONLY(&quot;MemberRO&quot;, m_vProperty3),
PLASMA_ACCESSOR_PROPERTY(&quot;MemberAccessor&quot;, GetInt, SetInt),
PLASMA_ACCESSOR_PROPERTY_READ_ONLY(&quot;MemberAccessorRO&quot;, GetInt),
</code></pre>
<p>To access an instance's member variable value, cast the property to <code>plAbstractMemberProperty</code> and call <code>plAbstractMemberProperty::GetPropertyType()</code> to determine the member type. Then either cast to <code>plTypedMemberProperty</code> of the matching type, or if the type is not known to you at compile time, use <code>plAbstractMemberProperty::GetPropertyPointer()</code> or <code>plAbstractMemberProperty::GetValuePtr()</code> and <code>plAbstractMemberProperty::SetValuePtr()</code> to access its data. The first solution will only return a valid pointer if the property is a direct member property.</p>
<h3 id="arrays">Arrays</h3>
<p>Array properties are very similar to member properties, they just handle arrays instead of single values. Direct array properties are declared via <code>PLASMA_ARRAY_MEMBER_PROPERTY(PropertyName, MemberName)</code> while accessor array properties are declared via <code>PLASMA_ARRAY_ACCESSOR_PROPERTY(PropertyName, GetCount, Getter, Setter, Insert, Remove)</code>. The accessor interface functions must have the following signature:</p>
<pre><code class="language-cpp">plUInt32 GetCount() const;
Type GetValue(plUInt32 uiIndex) const;
void SetValue(plUInt32 uiIndex, Type value);
void Insert(plUInt32 uiIndex, Type value);
void Remove(plUInt32 uiIndex);
</code></pre>
<p>The available macros are the following:</p>
<pre><code class="language-cpp">PLASMA_ARRAY_ACCESSOR_PROPERTY(&quot;ArrayAccessor&quot;, GetCount, GetValue, SetValue, Insert, Remove),
PLASMA_ARRAY_ACCESSOR_PROPERTY_READ_ONLY(&quot;ArrayAccessorRO&quot;, GetCount, GetValue),
PLASMA_ARRAY_MEMBER_PROPERTY(&quot;Hybrid&quot;, m_Hybrid),
PLASMA_ARRAY_MEMBER_PROPERTY(&quot;Dynamic&quot;, m_Dynamic),
PLASMA_ARRAY_MEMBER_PROPERTY_READ_ONLY(&quot;Deque&quot;, m_Deque),
</code></pre>
<p>To access an instance's array, cast the property to <code>plAbstractArrayProperty</code> and call <code>plAbstractArrayProperty::GetElementType()</code> to determine the element type. From here you can use the various functions inside <code>plAbstractArrayProperty</code> to manipulate an instance's array.</p>
<h3 id="sets">Sets</h3>
<p>Set properties are very similar to member properties, they just handle sets instead of single values. Direct set properties are declared via <code>PLASMA_SET_MEMBER_PROPERTY(PropertyName, MemberName)</code> while accessor set properties are declared via <code>PLASMA_SET_ACCESSOR_PROPERTY(PropertyName, GetValues, Insert, Remove)</code>. The accessor interface functions must have the following signature:</p>
<pre><code class="language-cpp">void Insert(Type value);
void Remove(Type value);
Container&lt;Type&gt; GetValues() const;
</code></pre>
<p>The available macros are the following:  </p>
<pre><code class="language-cpp">PLASMA_SET_ACCESSOR_PROPERTY(&quot;SetAccessor&quot;, GetValues, Insert, Remove),
PLASMA_SET_ACCESSOR_PROPERTY_READ_ONLY(&quot;SetAccessorRO&quot;, GetValues),
PLASMA_SET_MEMBER_PROPERTY(&quot;Set&quot;, m_SetMember),
PLASMA_SET_MEMBER_PROPERTY_READ_ONLY(&quot;SetRO&quot;, m_SetMember),
</code></pre>
<p>To access an instance's set, cast the property to <code>plAbstractSetProperty</code> and call <code>plAbstractSetProperty::GetElementType()</code> to determine the element type. From here you can use the various functions inside <code>plAbstractSetProperty</code> to manipulate an instance's set.</p>
<h2 id="flags">Flags</h2>
<p>Types as well as properties have flags that quickly let you determine the kind of type / property you are dealing with.
For types, <code>plRTTI::GetTypeFlags()</code> lets you access its <code>plTypeFlags::Enum</code> flags which are automatically deduced from the type at compile time.</p>
<p>Properties can have flags as well, <code>plAbstractMemberProperty::GetFlags()</code>, <code>plAbstractArrayProperty::GetFlags()</code> and <code>plAbstractSetProperty::GetFlags()</code> let you access the <code>plPropertyFlags::Enum</code> flags of the handled property type. The only difference here is that besides automatically deduced flags there are also user-defined flags that can be added during declaration of the property by using <code>plAbstractMemberProperty::AddFlags</code> and the variants on the other property categories:</p>
<pre><code class="language-cpp">PLASMA_ACCESSOR_PROPERTY(&quot;ArraysPtr&quot;, GetArrays, SetArrays)-&gt;AddFlags(plPropertyFlags::PointerOwner),
</code></pre>
<h2 id="limitations">Limitations</h2>
<ul>
<li>No two types can share the same name.</li>
<li>Each property name must be unique within its type.</li>
<li>Only constants that are a basic type (i.e. can be stored inside an <code>plVariant</code>) will be available to tools.</li>
<li>A pointer to a type cannot be its own type, the only exception to this is const char*.</li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../resource-management/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../resource-management/" class="btn btn-xs btn-link">
        Resource Management
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../filesystem/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../filesystem/" class="btn btn-xs btn-link">
        FileSystem
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/noraj/mkdocs-windmill-dark">Windmill Dark</a> theme by Alexandre ZANNI (noraj).</p>
</footer>

</body>
</html>