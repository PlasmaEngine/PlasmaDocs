<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="PlasmaDev">
    <link rel="canonical" href="https://plasmaengine.github.io/PlasmaDocs/runtime/world/world-overview/">
    <link rel="shortcut icon" href="../../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>The World / Scenegraph System - PlasmaDocs</title>
    <link href="../../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../../js/jquery-3.2.1.min.js"></script>
    <script src="../../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "The World / Scenegraph System", url: "#_top", children: [
              {title: "ECS", url: "#ecs" },
              {title: "Object Lifetime", url: "#object-lifetime" },
              {title: "Custom Components", url: "#custom-components" },
              {title: "Messaging", url: "#messaging" },
              {title: "Spatial System", url: "#spatial-system" },
              {title: "See Also", url: "#see-also" },
          ]},
        ];

    </script>
    <script src="../../../js/base.js"></script>
      <script src="../../../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../worlds/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../worlds/" class="btn btn-xs btn-link">
        Worlds
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../world-modules/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../world-modules/" class="btn btn-xs btn-link">
        World Modules
      </a>
    </div>
    
  </div>

    

    <h1 id="the-world-scenegraph-system">The World / Scenegraph System</h1>
<p>When you build a scene in the editor or through code, the structure of all the objects is stored in something that is commonly referred to as a <em>scenegraph</em>. In Plasma the scenegraph is implemented by the class <code>plWorld</code>, which is why the terms <em>scenegraph</em> and <em>world</em> are used interchangeably in our documentation.</p>
<h2 id="ecs">ECS</h2>
<p>In Plasma we use a variation of an <strong>E</strong>ntity <strong>C</strong>omponent <strong>S</strong>ystem (<a href="https://en.wikipedia.org/wiki/Entity_component_system">ECS</a>). It doesn't matter whether you are familiar with ECSs, but if you are, the main difference of our implementation to a pure ECS is, that in Plasma there is always exactly one <em>system</em> to handle each <em>component type</em>. You can have additional systems (see <a href="../world-modules/">World Modules</a>), however, this is not as common as in other engines.</p>
<p>The main classes involved are <code>plWorld</code>, <code>plGameObject</code>, <code>plComponent</code> and <code>plWorldModule</code> / <code>plComponentManager</code>.</p>
<h3 id="plworld">plWorld</h3>
<p>Each <code>plWorld</code> represents the entire state of a scene. Worlds hold all <a href="../game-objects/">game objects</a> and all <a href="../world-modules/">world modules</a>, which in turn hold all <a href="../components/">components</a>.</p>
<p>Each world has its own simulation state, such as a clock and a random number generator. Through the world modules, worlds also hold their own state for other simulation aspects, such as <a href="../../physics/jolt/jolt-overview.md">physics</a>.</p>
<p>You can have multiple worlds in parallel and they will be completely separated. This is for example the case when you have multiple <a href="../../../editor/editor-documents/">documents</a> open in the editor.</p>
<p>Worlds are described in more detail in <a href="../worlds/">this chapter</a>.</p>
<h3 id="plgameobject">plGameObject</h3>
<p><code>plGameObject</code> is our <em>entity</em> class. The terms <em>entity</em>, <em>game object</em> and <em>node</em> are used interchangeably. Every game object has a position, rotation and scale. It may be attached to a single <em>parent</em> game object and it may have multiple game objects attached as children. The game object hierarchy is a directed acyclic graph (DAG).</p>
<p>Game objects by themselves do not have any <em>behavior</em>. Instead, each game object can have an arbitrary number of <a href="../components/">components</a> attached.</p>
<p>The object's <em>transform</em> (position, rotation, scale) is local to its parent node, but it also holds a <em>global</em> transform, which is computed by concatenating the transformations of all parent nodes. Every time a game object or any of its parent nodes is moved, this global transform is updated.</p>
<p>Game objects are described in more detail in <a href="../game-objects/">this chapter</a>.</p>
<h3 id="plcomponent">plComponent</h3>
<p>Components can be attached to game objects. They bring their own data and functionality. Components are used to implement behavior. For example light source components are used to tell the renderer how to light the scene, physics components are used to make objects collide with each other and AI components let creatures run around. By attaching components to game objects, you configure how that game object behaves. Components can interact with or depend on each other. For example a physics <em>actor</em> component would make an object fall to the ground, but it also needs a physics <em>shape</em> component to know whether the object should behave like a box, a sphere or something else.</p>
<p>Components are described in more detail in <a href="../components/">this chapter</a>.</p>
<h3 id="plworldmodule-plcomponentmanager">plWorldModule / plComponentManager</h3>
<p>World modules are the <em>systems</em> of the ECS pattern. Worlds are updated in multiple phases. Some phases are multi-threaded, others aren't. World modules can hook into these phases and make sure that they are called at the right time. World modules implement things like stepping third party code (e.g. physics). The most common type of world modules are <em>component managers</em>. Each component type has its own component manager, which is responsible for updating those components. The manager can leverage knowledge from other sources for determining which components need updating, and it can easily update components in a multi-threaded fashion, if it is save to do so.</p>
<p>World modules are described in more detail in <a href="../world-modules/">this chapter</a> and component managers in <a href="../component-managers/">this chapter</a>.</p>
<h2 id="object-lifetime">Object Lifetime</h2>
<p>The Plasma scenegraph does not use any kind of reference counting or garbage collection, however it does provide weak reference semantics through <em>handles</em>, to enable you to delete objects exactly when you need them to be removed, while still being able to detect whether an object is still alive.</p>
<p>See the <a href="../object-lifetime/">object lifetime chapter</a> for details.</p>
<h2 id="custom-components">Custom Components</h2>
<p>A large part of writing your own game, is to write your own components. If you need maximum control and performance, you need to write your <a href="../../../custom-code/cpp/custom-cpp-component/">components in C++</a>.</p>
<p>You can also write components in <a href="../../../custom-code/typescript/typescript-overview/">TypeScript</a>. Their functionality is very similar but a bit more limited. It is possible to use both and communicate between Typescript and C++ components using <a href="../world-messaging/">messages</a>.</p>
<h2 id="messaging">Messaging</h2>
<p>When a component gets updated, it can access other components and call functions on them. Of course that requires that the other component type is known at compile time. In practice, that is often not the case.</p>
<p>Take the <a href="../../../gameplay/projectile-component/">projectile component</a> as an example. Whenever a projectile hits something, it should apply damage to the hit object. However, what it hit was just the physical representation of an object (e.g. a <a href="../../physics/jolt/actors/jolt-actors.md">physics actor</a>). The physics object doesn't have a concept of 'receiving damage' and therefore calling some 'OnDamage' function on the physics component makes no sense.</p>
<p>Instead, on the object that has the physics component, there may be another component which knows how it would react to damage, so we want to send the information there. That component may be a custom component, though, which the projectile component knows nothing about, so there is no way to call a function on that.</p>
<p>To solve this problem, you can send <em>messages</em> to components. A message is a class derived from <code>plMessage</code> and it can contain arbitrary data. Each component registers <em>message handlers</em> for all the types of messages that it wants to receive.</p>
<p>When our projectile component now hits some object, it simply sends a <em>damage message</em> to that object. The engine will then deliver that message to all components which have a matching message handler. The message can be delivered right away, in which case a result can be written back to the message, or with a delay.</p>
<p>Using messages decouples code, as components that know nothing of each other can still communicate and interact. The message system is also highly optimized for best performance.</p>
<p>Messages are described in more detail in <a href="../world-messaging/">this chapter</a>.</p>
<h2 id="spatial-system">Spatial System</h2>
<p>The world also sorts objects into a spatial system, to enable efficient queries for which objects are within a certain area. Although this is the basis for frustum culling in the renderer, it is also available to other systems.</p>
<p>See <a href="../spatial-system/">this chapter</a> for details.</p>
<h2 id="see-also">See Also</h2>
<ul>
<li><a href="../worlds/">Worlds</a></li>
<li><a href="../game-objects/">Game Objects</a></li>
<li><a href="../components/">Components</a></li>
<li><a href="../world-modules/">World Modules</a></li>
<li><a href="../component-managers/">Component Managers</a></li>
<li><a href="../world-messaging/">Messaging</a></li>
<li><a href="../../../custom-code/custom-code-overview/">Custom Code</a></li>
</ul>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../worlds/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../worlds/" class="btn btn-xs btn-link">
        Worlds
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../world-modules/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../world-modules/" class="btn btn-xs btn-link">
        World Modules
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/noraj/mkdocs-windmill-dark">Windmill Dark</a> theme by Alexandre ZANNI (noraj).</p>
</footer>

</body>
</html>