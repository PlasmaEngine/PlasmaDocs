<!DOCTYPE html>
<html lang="en">
<head>
  
  
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="author" content="PlasmaDev">
    <link rel="canonical" href="https://plasmaengine.github.io/PlasmaDocs/tools/headercheck/">
    <link rel="shortcut icon" href="../../img/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <title>HeaderCheck Tool - PlasmaDocs</title>
    <link href="../../css/bootstrap-3.3.7.min.css" rel="stylesheet">
    <link href="../../css/font-awesome-4.7.0.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link rel="stylesheet" href="../../css/highlight.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <script src="../../js/jquery-3.2.1.min.js"></script>
    <script src="../../js/bootstrap-3.3.7.min.js"></script>
    <script src="../../js/highlight.pack.js"></script>
    
    <base target="_top">
    <script>
      var base_url = '../..';
      var is_top_frame = false;
        
        var pageToc = [
          {title: "HeaderCheck Tool", url: "#_top", children: [
              {title: "Types of Header Files", url: "#types-of-header-files" },
              {title: "The Header Checker Tool", url: "#the-header-checker-tool" },
              {title: "Hiding Implementation Detail", url: "#hiding-implementation-detail" },
              {title: "See Also", url: "#see-also" },
          ]},
        ];

    </script>
    <script src="../../js/base.js"></script>
      <script src="../../search/main.js"></script> 
</head>

<body>
<script>
if (is_top_frame) { $('body').addClass('wm-top-page'); }
</script>



<div class="container-fluid wm-page-content">
  <a name="_top"></a>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../inspector/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../inspector/" class="btn btn-xs btn-link">
        plInspector
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../fileserve/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../fileserve/" class="btn btn-xs btn-link">
        FileServe
      </a>
    </div>
    
  </div>

    

    <h1 id="headercheck-tool">HeaderCheck Tool</h1>
<h2 id="types-of-header-files">Types of Header Files</h2>
<p>The code in Plasma Engine differentiates between two types of header files:</p>
<ul>
<li><strong>Public Header Files</strong>: Public header files are header files that can be included by third party. These header files should not leak any implementation details like platform headers. A third party is any library or executable outside of the currently compiled library / executable. For example when plFoundation is compiled, everything else is considered a third party.</li>
<li><strong>Internal Header Files</strong>: Internal header files may include platform headers and leak implementation detail, but can only be used within a subcomponent of Plasma Engine (for example only inside plFoundation). Using them from outside of the component will cause a compiler error.</li>
</ul>
<p>To mark up a header file as a internal header file, first include the component's internal.h file and then use the component specific macro. The component's internal header file is called <code>ComponentInternal.h</code> and the macro is called <code>PLASMA_COMPONENT_INTERNAL_HEADER</code>.</p>
<p>The following example shows how to mark a header file as internal for plFoundation:</p>
<pre><code class="language-cpp">#include &lt;Foundation/FoundationInternal.h&gt;
PLASMA_FOUNDATION_INTERNAL_HEADER
</code></pre>
<h2 id="the-header-checker-tool">The Header Checker Tool</h2>
<p>The header checker tool will automatically be run by the continues integration to check for leakage of implementation detail. If a leak is found the build will fail. Usually you will see an error message such as:</p>
<pre><code class="language-plaintext">Including 'wrl/wrappers/corewrappers.h' in Plasma/Code/Engine/Foundation/Strings/StringConversion.h:9 leaks underlying implementation detail. Including system or thirdparty headers in public Plasma header files is not allowed. Please use an interface, factory or pimpl to hide the implementation and avoid the include.
</code></pre>
<p>In this example including <code>wrl/wrappers/corewrappers.h</code> is illegal. This header file is included from <code>Plasma/Code/Engine/Foundation/Strings/StringConversion.h</code> at line 9. To fix these issues follow one of the techniques below to hide implementation details.</p>
<h2 id="hiding-implementation-detail">Hiding Implementation Detail</h2>
<p>To consider the different options of hiding implementation detail have a look at the following example</p>
<pre><code class="language-cpp">#include &lt;d3d11.h&gt;

class plTexture2D
{
public:
    void Bind();

private:
    ID3D11Texture2D* m_ptr;
};
</code></pre>
<p>If a user includes this header file, the underlying implementation detail is leaked as the user will need the <code>d3d11.h</code> header in order to compile the code. Furthermore the user might need exactly the same version of the <code>d3d11.h</code> file in order for the code to compile. This is a leaky abstraction. Ideally classes that wrap functionality should not leak any of their implementation details to the user. The following techniques can be used to hide implementation detail.</p>
<h3 id="forward-declarations">Forward Declarations</h3>
<p>Forward declarations can be used to remove the need to include a header file, therefor removing the leaky abstraction. Consider the following fixed version of the <code>plTexture2D</code> class:</p>
<pre><code class="language-cpp">struct ID3D11Texture2D; // Forward declare ID3D11Texture2D

class plTexture2D
{
public:
    void Bind();

private:
    ID3D11Texture2D* m_ptr;
};
</code></pre>
<p>This header is no longer a leaky abstraction as the user is no longer required to have a copy of <code>d3d11.h</code>.</p>
<p>Forward declarations can be made for:</p>
<ul>
<li>Class or struct members if they are pointers or references.</li>
<li>All types used as arguments to functions.</li>
<li>Template arguments if the usage follows the two above rules.</li>
</ul>
<p>Forward declarations can't be made for:</p>
<ul>
<li>Class or struct members that are 'inline' because the compiler needs to know the size and alignment.</li>
<li>Base classes.</li>
</ul>
<p>Enums can be forward declared if they are given an explicit storage type. So ideally to make enums forward declarable always manually specify a storage type.</p>
<pre><code class="language-cpp">enum MyEnum : int; // Forward declaration

enum MyEnum : int // declaration
{
    One,
    Two
};
</code></pre>
<p>Nested types can never be forward declared. A nested type is a type that is inside a class or struct.</p>
<pre><code class="language-cpp">// does not work
// struct Outer::Inner;

struct Outer
{
    struct Inner
    {
        int i;
    };
};
</code></pre>
<p>So prefer to put nested types into namespaces instead of structs or classes:</p>
<pre><code class="language-cpp">// Forward declaration
namespace Outer
{
    struct Inner;
}

// Declaration
namespace Outer
{
    struct Inner
    {
        int i;
    };
}
</code></pre>
<p>Templates can also be forward declared:</p>
<pre><code class="language-cpp">
// forward declaration
template&lt;typename&gt; struct Example;

// Usage of forward declaration
void bar(const Example&lt;int&gt;&amp; arg);

// declaration
template&lt;typename T&gt;
struct Example
{
    T t;
};
</code></pre>
<p><strong>Advantages:</strong></p>
<ul>
<li>No runtime overhead</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Forward declarations and actual declaration have to be kept in sync.</li>
</ul>
<h3 id="moving-implementation-details-out-of-templates">Moving Implementation Details Out Of Templates</h3>
<p>Consider the following example which leaks implementation details:</p>
<pre><code class="language-cpp">// Application.h

#include &lt;roapi.h&gt;

template &lt;typename AppClass&gt;
void RunApplication(AppClass&amp; app)
{
    RoInitialize(RO_INIT_MULTITHREADED);

    app.Init();

    while(!app.Run()) {}

    app.DeInit();

    RoUninitialize();
}
</code></pre>
<p>The two functions <code>RoInitialize</code> and <code>RoUninitialize</code> are platform specific functions and require the include <code>roapi.h</code>. We can't move the function into a .cpp because the implementation for templates needs to be known when using them. As a result this template leaks its implementation detail.</p>
<p>To fix this issue we need to wrap the leaking function calls into separate functions and forward declare these functions.</p>
<pre><code class="language-cpp">// Application.h

void InitPlatform();
void DeInitPlatform();

template &lt;typename AppClass&gt;
void RunApplication(AppClass&amp; app)
{
    InitPlatform();

    app.Init();

    while(!app.Run()) {}

    app.DeInit();

    DeInitPlatform();
}
</code></pre>
<pre><code class="language-cpp">// Application.cpp
#include &quot;Application.h&quot;
#include &lt;roapi.h&gt;

void InitPlatform()
{
    RoInitialize(RO_INIT_MULTITHREADED);
}

void DeInitPlatform()
{
    RoUninitialize();
}
</code></pre>
<p>As you can see we removed the include to <code>roapi.h</code> from the header file and moved it into the cpp file. This way our header no longer leaks underlying implementation details, as the user won't see the cpp file when using our library. If considerable parts of the template don't depend on the template arguments this pattern can also be used to reduce code bloat by moving the non dependent parts out into non-templated functions.</p>
<h3 id="pimpl-light">Pimpl Light</h3>
<p>The pattern that I call "Pimpl light" can be used to hide implementation detail at the cost of an additional allocation:</p>
<p>Consider our original <code>plTexture2D</code> example it would be modified like this:</p>
<pre><code class="language-cpp">// Texture2D.h
class plTexture2D
{
public:
    plTexture2D();
    ~plTexture2D();
    void Bind();

private:
    struct Impl; // forward declaration

    plUniquePtr&lt;Impl&gt; m_pImpl;
};
</code></pre>
<pre><code class="language-cpp">// Texture2D.cpp
#include &quot;Texture2D.h&quot;
#include &lt;d3d11.h&gt;

// Declaration of plTexture2D::Impl struct
struct plTexture2D::Impl
{
    ID3D11Texture2D* m_ptr;
};

plTexture2D::plTexture2D()
: m_pImpl(PLASMA_DEFAULT_NEW(Impl))
{

}

// all constructors / destructors / assignment operators must be in .cpp file otherwise forward declaration will not work.
plTexture2D::~plTexture2D()
{

}

plTexture2D::Bind()
{
    // Use the implementation detail
    m_pImpl-&gt;m_ptr-&gt;Bind();
}
</code></pre>
<p>This is an easy pattern to hide implementation details.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>Simple to implement, hides nasty implementation details well</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Additional allocation</li>
<li>Additional indirection</li>
</ul>
<h3 id="pimpl-inheritance">Pimpl Inheritance</h3>
<p>The Pimpl pattern can also be implemented by using inheritance instead of a forward declared struct. For our <code>plTexture2D</code> example it would look like this:</p>
<pre><code class="language-cpp">// Texture2D.h
class plTexture2D
{
public:
    plUniquePtr&lt;plTexture2D&gt; Make(); // factory function, could also return a shared ptr.
    virtual ~plTexture2D();
    void Bind();

private:
    plTexture2D(); // All constructors must be private

    friend class plTexture2DImpl; // This is the only class allowed to derive from plTexture2D
};
</code></pre>
<pre><code class="language-cpp">// Texture2D.cpp
#include &quot;Texture2D.h&quot;
#include &lt;d3d11.h&gt;

// Actual implementation
class plTexture2DImpl : public plTexture2D
{
public:
    plTexture2DImpl() : plTexture2D() {}
    ~plTexture2DImpl(){}

    ID3D11Texture2D* m_ptr;
};


plTexture2D::plTexture2D() {}
plTexture2D::~plTexture2D() {}

plUniquePtr&lt;plTexture2D&gt; plTexture2D::Make()
{
    return plUniquePtr&lt;plTexture2D&gt;(PLASMA_DEFAULT_NEW(plTexture2DImpl));
}

plTexture2D::Bind()
{
    // Use the implementation detail
    reinterpret_cast&lt;plTexture2DImpl*&gt;(this)-&gt;m_ptr-&gt;Bind();
}
</code></pre>
<p>As you see this version of pimpl hides the implementation detail similar to pimpl light.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>No additional indirection (compared to pimpl light)</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Additional allocation</li>
<li>Can no longer inherit from <code>plTexture2D</code></li>
<li><code>plTexture2D</code> can't be <code>final</code></li>
</ul>
<h3 id="opaque-array-of-bytes">Opaque array of bytes</h3>
<p>We can also place an opaque array of bytes large enough to store our implementation detail. Considering our <code>plTexture2D</code> example it would look like this:</p>
<pre><code class="language-cpp">// plTexture2D.h

class plTexture2D
{
public:
    void Bind();

private:
#if PLASMA_ENABLED(PLASMA_PLATFORM_32BIT)
    struct PLASMA_ALIGN(Impl, 4)
    {
        plUInt8 m_Data[4];
    };
#else
    struct PLASMA_ALIGN(Impl, 8)
    {
        plUInt8 m_Data[8];
    };
#endif
    Impl m_impl;
};
</code></pre>
<pre><code class="language-cpp">// plTexture2D.cpp
#include &quot;Texture2D.h&quot;

struct plTexture2DImpl
{
    D3D11Texture2D* m_ptr;
};

static_assert(sizeof(plTexture2D::Impl) == sizeof(plTexture2DImpl), &quot;plTexture2D::Impl has incorrect size&quot;);
static_assert(alignof(plTexture2D::Impl) == alignof(plTexture2DImpl), &quot;plTexture2D::Impl has incorrect alignment&quot;);

void plTexture2D::Bind()
{
    // Use implementation detail
    reinterpret_cast&lt;plTexture2DImpl*&gt;(&amp;m_impl)-&gt;m_ptr-&gt;Bind();
}
</code></pre>
<p>This again hides the implementation details in the header file.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li>No runtime overhead</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>High maintenance burden. Especially if implementation detail size varies on different platforms.</li>
</ul>
<h3 id="ignore-the-problem">Ignore the problem</h3>
<p>You can choose to ignore the leaky abstraction issue and tell the header checker tool to ignore a certain file to be included or give a certain file the permission to include anything.</p>
<p>Each module in PlasmaEngine that uses the header checker has a headerCkeckerIgnore.json file where you can add ignores. It looks like this:</p>
<pre><code class="language-json">{
    &quot;includeTarget&quot; :
    {
        &quot;byName&quot; : [
            &quot;a.h&quot;
        ]
    },
    &quot;includeSource&quot; :
    {
        &quot;byName&quot; : [
            &quot;b.h&quot;
            ]
    }
}
</code></pre>
<ul>
<li>In the above file every time <code>a.h</code> is included and would generate an error in the header checker tool, that error will be ignored.</li>
<li>Every time <code>b.h</code> includes a header file that would cause an error, this error will also be ignored.</li>
</ul>
<p><strong>Advantages:</strong></p>
<ul>
<li>Less work</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>Longer compile times</li>
<li>Conflicts due to global namespace pollution</li>
<li>Requires users to have all header files for implementation details available</li>
</ul>
<h2 id="see-also">See Also</h2>

  <br>
    

    
    
      
    

  <div class="row wm-article-nav-buttons" role="navigation" aria-label="navigation">
    
    <div class="wm-article-nav pull-right">
      <a href="../inspector/" class="btn btn-xs btn-default pull-right">
        Next
        <i class="fa fa-chevron-right" aria-hidden="true"></i>
      </a>
      <a href="../inspector/" class="btn btn-xs btn-link">
        plInspector
      </a>
    </div>
    
    <div class="wm-article-nav">
      <a href="../fileserve/" class="btn btn-xs btn-default pull-left">
        <i class="fa fa-chevron-left" aria-hidden="true"></i>
        Previous</a><a href="../fileserve/" class="btn btn-xs btn-link">
        FileServe
      </a>
    </div>
    
  </div>

    <br>
</div>

<footer class="col-md-12 wm-page-content">
  <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a> using <a href="https://github.com/noraj/mkdocs-windmill-dark">Windmill Dark</a> theme by Alexandre ZANNI (noraj).</p>
</footer>

</body>
</html>